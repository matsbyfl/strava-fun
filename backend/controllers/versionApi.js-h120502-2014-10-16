var _ = require('underscore');
var mysql = require('mysql');
var config = require("../../config/config");
var Q = require('q');
var async = require('async');

var pool = mysql.createPool({
    host: config.dbUrl,
    user: config.dbUser,
    password: config.dbPassword,
    database: config.dbSchema
});
var app = require('express')();

exports.registerDeployment = function () {
    return function (req, res, next) {
        validateProperties(req.body);

        var appName = req.body.application;
        var envName = req.body.environment;
        var version = req.body.version;
        var deployedBy = req.body.deployedBy;

        Q.all([getApp(appName, true, false), getEnv(envName, true, false)]).then(function (results) {
            registerVersion(results, version, deployedBy, res)
        }).catch(function (err) {
            next(err); 
        }).done();

    }
} 

exports.getVersion = function () {
    return function (req, res, next) {
 
        res.contentType("application/json");

        console.log("");
        var appName = req.query.application;
        var envName = req.query.environment;

        if (isAbsent(envName) && isPresent(appName)) { 
            console.log("Enviroment name not provided.");
            getVersionByApplication(appName, function(listEnvsAndVersion) {

                var list = [];
                for (var key in listEnvsAndVersion) {
                    var envName = listEnvsAndVersion[key].env_name;
                    var version = listEnvsAndVersion[key].version;
                    var retObj = createReturnObject(appName, envName, version);
                    list.push(retObj);
                }

                res.write(JSON.stringify(list));
                res.send();    

            });
        } 
        else if (isPresent(envName) && isAbsent(appName)) {
            console.log("Application name not provided.");

            getVersionByEnvironment(envName).then(function(listAppsAndVersion) {

                var list = [];
                for (var key in listAppsAndVersion) {
                    var appName = listAppsAndVersion[key].app_name;
                    var version = listAppsAndVersion[key].version;
                    var retObj = createReturnObject(appName, envName, version);
                    list.push(retObj);
                }

                res.write(JSON.stringify(list));
                res.send();    

            });
        }

        else if (isPresent(envName) && isPresent(appName)) {
            Q.all([getApp(appName, false, true), getEnv(envName, false, true)]).then(function (results) {

                var appIDs = results[0];
                var envIDs = results[1];

                /* Backwards compatibilty: getApp and getEnv return only a single value 
                   when only one match is found. When multiple values, and array is returned. 
                   Instead of rewriting getApp and getEnv, for now we'll convert single values 
                   to single item arrays here. 
                   */
                if (typeof appIDs.length === 'undefined') {
                    appIDs = [ appIDs ];
                }
                if (typeof envIDs.length === 'undefined') {
                    envIDs = [ envIDs ];
                }

                var list = [];

                console.log("AppIDs "+ appIDs);
                console.log("EnvIDs "+ envIDs);
                res.write(JSON.stringify(list)); 
                res.send(); 
               

            });
            }
            else {
            //getVersionByApplication(appName, function(listEnvsAndVersion) {

                getAllVersions(function(listAllVersion) {

                    var list = [];
                    for (var key in listAllVersion) {
                        var appName = listAllVersion[key].app_name;
                        var envName = listAllVersion[key].env_name;
                        var version = listAllVersion[key].version;
                        var retObj = createReturnObject(appName, envName, version);
                        list.push(retObj);
                    }

                    res.write(JSON.stringify(list));
                    res.send();    

                });

            }
        }
    }

    function createReturnObjectList(appIDs, envIDs) {
        var the_promises = [];

        console.log("IN aaa()");        
        appIDs.forEach(function(thing) {
            var deferred = Q.defer();
            console.log("appID " + appID);
            getReturnObjectForVersion(appID, envID, function (result) {
                console.log(".... ....");
                deferred.resolve(result);
            });
            the_promises.push(deferred.promise);

        });
        console.log("OUT aaa()");
        return Q.all(the_promises);
    }
    

    function aaa_v1(appIDs, envIDs) {
        var deferred = Q.defer();

        console.log("IN aaa()");
        var list = [];
        for (i = 0; i < appIDs.length; i++) {
            var appID = appIDs[i];

            for (j = 0; j < envIDs.length; j++) {
                var envID = envIDs[j];

                //console.log("Looking up version info for appID " + appID + " in envID " + envID);

                getReturnObjectForVersion(appID, envID).then(function (object) {
                    list[i] = object;
                });
            }
        }
        deferred.resolve(list);
        console.log("Leaving aaa()");
        return deferred.promise;        
    }

    function getReturnObjectForVersion(appID, envID) {
        var deferred = Q.defer();

        getVersionInfoSync(appID,envID).then(function (version) {
            getAppNameById(appID).then(function(appName) {
                getEnvNameById(envID).then(function(envName) {

                    var retObj = createReturnObject(appName, envName, version);
                    console.log("Adding return object to list");
                    console.log(JSON.stringify(retObj));
                    
                    deferred.resolve(JSON.stringify(retObj));
                });
            });
        });


        return deferred.promise;
    }

    function createReturnObjectList_old(appIDs, envIDs) {
        var deferred = Q.defer();
        console.log("Length: " + appIDs.length);
        // We may have multiple application IDs, so let's loop through these
        var retObjects = [];
        for (i = 0; i < appIDs.length; i++) {
            console.log("AppID: " + appIDs[i]);
            var appID = appIDs[i];

            
            getVersionInfoSync(appIDs[i],envIDs[0]).then(function (version) {
                console.log("Version ... "+ version);
                getAppNameById(appID).then(function(appName) {
                    console.log("bbb appname " + appName);
                    var retObj = createReturnObject(appName, envName, version);

                    console.log("Adding return object to list");
                    console.log(JSON.stringify(retObj));
                    retObjects[i] = JSON.stringify(retObj);
                    deferred.resolve(retObjects);
                });
            });
        }

        return deferred.promise;
    }

    function getAllVersions(callback) {
    //var sqlStatement = "select * from version where tom_date is null and ver_type in (0, 11) order by env_type, app_type;";
    var sqlStatement = "select * from view_version";
        //var sqlStatement = "select app_type,version from version where env_type = ? and tom_date is NULL order by ver_id DESC";
        console.log(sqlStatement);  

        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query(sqlStatement, function (err, row) {

                if (err) {  
                    console.log("Failed to get list of all applications");
                    throw err;
                }

                connection.release();
                callback(row);

            })
        });    
    }

    function getAppNameById(appID) {
        var deferred = Q.defer();

        console.log("Getting appName for appID " + appID);
        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query("select app_name from t_application where app_id = ?", appID, function (err, rows) {
                if (err) {
                    deferred.reject(new Error(err));
                } else if (rows.length === 0) {
                    deferred.reject(new Error("The database returned zero environments."));
                } else if (rows.length > 0) {
                //ound these environments: ");
                //console.log(rows);
                deferred.resolve(rows[0].app_name);
            } else {
                throw new Error("Something went wrong when getting application name.");
            }
        });

            connection.release();
        });

        return deferred.promise;
    }

    function getEnvNameById(envID) {
        var deferred = Q.defer();

        console.log("Getting envName for envID " + envID);
        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query("select env_name from t_environment where env_id = ?", envID, function (err, rows) {
                if (err) {
                    deferred.reject(new Error(err));
                } else if (rows.length === 0) {
                    deferred.reject(new Error("The database returned zero environments."));
                } else if (rows.length > 0) {
                //ound these environments: ");
                //console.log(rows);
                deferred.resolve(rows[0].env_name);
            } else {
                throw new Error("Something went wrong when getting environment name.");
            }
        });

            connection.release();
        });

        return deferred.promise;
    }



    function isAbsent(parm) {
        if (parm == "" || parm == null) return true;
        return false;
    }

    function isPresent(parm) {
        if (parm == "" || parm == null) return false;
        return true;
    }

    function getAllEnvironments() {
        var deferred = Q.defer();

        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query("select env_name from t_environment", function (err, rows) {
                if (err) {
                    deferred.reject(new Error(err));
                } else if (rows.length === 0) {
                    deferred.reject(new Error("The database returned zero environments."));
                } else if (rows.length > 0) {
                //ound these environments: ");
                //console.log(rows);
                deferred.resolve(rows);
            } else {
                throw new Error("Something went wrong when getting environments");
            }
        });

            connection.release();
        });

        return deferred.promise;
    }

    function getAllApplications(callback) {
        var sqlStatement = "select app_name from t_application;";
        //var sqlStatement = "select app_type,version from version where env_type = ? and tom_date is NULL order by ver_id DESC";
        console.log(sqlStatement);  

        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query(sqlStatement, function (err, row) {

                if (err) {  
                    console.log("Failed to get list of all applications");
                    throw err;
                }

                connection.release();
                callback(row);

            })
        });    
    }

    function getVersionByApplication(appName, callback) {
        Q.all([getApp(appName, false)]).then(function (results) {

            var appId = results[0];
            var sqlStatement = "select env_name,version from version join t_environment on version.env_type = t_environment.env_id where app_type = ? and tom_date is NULL order by ver_id DESC;";
            console.log(sqlStatement);  

            pool.getConnection(function (err, connection) {
                if (err) throw err;

                connection.query(sqlStatement, appId, function (err, row) {

                    if (err) {  
                        console.log("Failed to get version info for application");
                        throw err;
                    }

                    connection.release();
                    callback(row);

                });

            });
        }).catch(function (err) {
            console.log("Failed to get id for environment. Returning an empty object.");
            console.log(err); 
            // Something went wrong, so lets return an empty object
            var retObj = createReturnObject("", "", "");
            callback(retObj);
        }).done();    
    }



    function getVersionByEnvironment(envName, callback) {
        var deferred = Q.defer();

        Q.all([getEnv(envName, false)]).then(function (results) {

            var envId = results[0];
            var sqlStatement = "select app_name,version from version join t_application on version.app_type = t_application.app_id where env_type = ? and tom_date is NULL order by ver_id DESC";
        //var sqlStatement = "select app_type,version from version where env_type = ? and tom_date is NULL order by ver_id DESC";
        //console.log("Getting app_type,version info envname " + envName + " with envID " + envId); 
        console.log("select version from version where env_type = " + envId + " and tom_date is NULL");

        pool.getConnection(function (err, connection) {
            if (err) throw err;

            connection.query(sqlStatement, envId, function (err, row) {

                if (err) { 
                    console.log("Failed to get version info for application");
                    throw err;
                }

                //console.log("Row: " + row);  
                //var ret = row[0].version;
                //console.logq("Got version for application: ", row[0], " version ", ret);
                connection.release();
                //callback(row);
                deferred.resolve(row);

            });

        });
    }).catch(function (err) {
        console.log("Failed to get id for environment. Returning an empty object.");
        console.log(err); 
            // Something went wrong, so lets return an empty object
            var retObj = createReturnObject("", "", "");
            //callback(retObj);
            deferred.reject(retObj);
            //res.write(JSON.stringify(retObj));
            //res.send();
            //next(err); 

        }).done();    
    //console.log("Ferdig med promise.")
    return deferred.promise;

}

function createReturnObject(application, environment, version) {
    console.log("Creating return object for application " + application + " in environment " + environment + " with version " + version);
    var objToJson = { };
    objToJson.application = application; 
    objToJson.environment = environment;
    objToJson.version = version;
    return objToJson;

}

function getVersionInfoSync(appId, envId) {
    var def = Q.defer();

    // var appId = result[0];
    // var envId = result[1];

    console.log("Getting version for appID " + appId + " in envID " + envId);

    pool.getConnection(function (err, connection) {
        if (err) throw err;
        //console.log("select version from version where app_type = ? and env_type = ? and tom_date is NULL order by ver_id DESC", [appId, envId]);
        //connection.query('insert into t_application (app_name, ver_type, description, is_active) values(?,?,?,?)', [appname, 0, appname, 0], function (err, result) {
            connection.query("select version from version where app_type = ? and env_type = ? and tom_date is NULL order by ver_id DESC", [appId, envId], function (err, row) {            
                //connection.query("select env_name, app_name, version from view_version where app_name = ? and env_type = ? and tom_date is NULL order by ver_id DESC", [appId, envId], function (err, row) {            
                    if (err) throw  err;
                    console.log("Found version " + row[0].version + " for appID " + appId + " in envID " + envId);
                    def.resolve(row[0].version);
                });

            connection.release();
        });

return def.promise;
}

function getVersionInfo(result, version, deployedBy, res, callback) {
    var appId = result[0];
    var envId = result[1];

    console.log("GFGFGFGFGFGF");
    console.log("Getting version info for appID " + appId + " in envID " + envId);
    console.log("select version from version where app_type in (" + appId + ") and env_type = " + envId + " and tom_date is NULL");

    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query("select version from version where app_type in (?) and env_type = ? and tom_date is NULL order by ver_id DESC", [appId, envId], function (err, row) {

            if (err) { 
                console.log("Failed to get version info for application");
                throw err;
            }
            
            //console.log("TODO: Må resolve alle applikasjonsnavnene før man kaller getVersionInfo (denne må kalles èn gang pr application!");

            /*var list = [];
            for (i = 0; i < row.length; i++) {
                console.log("Got version for application: ", row[i].version);
                list[i] = row[i].version;
                callback(list);
            }*/

            var ret = row[0].version;
            callback(ret);
            

        });

        connection.release();
    });

}




function registerVersion(result, version, deployedBy, res) {
    var appId = result[0];
    var envId = result[1];

    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query("update version set tom_date = ? where app_type = ? and env_type = ? and tom_date is NULL", [new Date(), appId, envId], function (err, res) {
            if (err) throw err;
            console.log("Set tom_date on %s row(s)", res.affectedRows);
        });

        connection.query("insert into version set app_type = ?, env_type = ?, ver_type = ?, version = ?, fom_date = ?, deployer = ?, tom_date = NULL", [appId, envId, 0, version, new Date(), deployedBy], function (err, res) {
            if (err) throw err;
            console.log("Added new version with id " + res.insertId);
        });

        connection.release();
    });

    res.send(200);
} 

function createApp(appname) {
    var def = Q.defer();
    console.log('Creating app %s', appname);

    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query('insert into t_application (app_name, ver_type, description, is_active) values(?,?,?,?)', [appname, 0, appname, 0], function (err, result) {
            if (err) throw  err;
            def.resolve(result.insertId);
        });

        connection.release();
    });

    return def.promise;
}


function createEnv(envName) {
    var def = Q.defer();
    console.log('Creating environment %s', envName);

    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query('insert into t_environment (env_name, is_active) values(?,?)', [envName, 0], function (err, result) {
            if (err) throw  err;
            var envId = result.insertId;
            def.resolve(envId);
        });

        connection.release();
    });

    return def.promise;
}

function getApp(appname, createIfMissing, allowWildcardAppname) {
    var deferred = Q.defer();

    if (appname.indexOf("*") >= 0 && allowWildcardAppname == false) {
       deferred.reject(new Error("Wildcard application names are not allowed.")); 
       console.log("ERROR: Wildcard application names are not allowed.");
       return deferred.promise;
   }

    // MySQL uses "%"" as wildcard
    appname = appname.replace("*", "%");
    
    console.log(config.dbUrl);
    //console.log("host: " + pool.get(host));
    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query('select app_id from t_application where app_name like ?', [appname], function (err, rows) {
            if (err) {
                deferred.reject(new Error(err));
            } else if (rows.length === 0) {
                if (createIfMissing) { 
                    console.log("No app found. Will create it now.");
                    createApp(appname).then(function (val) {
                        deferred.resolve(val);
                    });
                }
                else deferred.reject(new Error("Application does not exist."));
            } else if (rows.length === 1) {
                var applicationId = rows[0].app_id;
                console.log('Application exists with ID ' + applicationId);
                deferred.resolve(applicationId);
                //console.log("Set resolve value to %s", applicationId);
            } else if (rows.length > 1) {
                var list = [];
                for(i = 0; i < rows.length; i++) {
                    console.log("Adding id to list: " + rows[i].app_id);
                    list[i] = rows[i].app_id;
                }
                deferred.resolve(list);
            }
            else {
                throw new Error("Something went wrong when getting app");
            }
        });

connection.release();
});

return deferred.promise;
}

function getEnv(envName, createIfMissing) {
    var deferred = Q.defer();

    pool.getConnection(function (err, connection) {
        if (err) throw err;

        connection.query("select env_id from t_environment where env_name = ?", [envName], function (err, rows) {
            if (err) {
                deferred.reject(new Error(err));
            } else if (rows.length === 0) {
                if (createIfMissing) {
                    console.log("No env found. Will create it now.");
                    createEnv(envName).then(function (val) {
                        deferred.resolve(val);
                    });
                }
                else {
                    deferred.reject(new Error("Environment does not exist."));
                }
            } else if (rows.length === 1) {
                var envId = rows[0].env_id;
                console.log('Environment exists with ID ' + envId);
                deferred.resolve(envId);
            } else {
                throw new Error("Something went wrong when getting env");
            }
        });

        connection.release();
    });

return deferred.promise;
}

function validateProperties(jsonObj) {
    var requiredKeys = ["application", "environment", "version", "deployedBy"];
    for (var idx in requiredKeys) {
        var key = requiredKeys[idx]
        if (!_.has(jsonObj, key)) {
            throw new Error("Unable to find required property " + key);
        }
    }
}
